'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _isEmpty = require('lodash/isEmpty');
var _isObject = require('lodash/isObject');
var _merge = require('lodash/merge');

function isEmpty(v) {
    if (['boolean', 'number'].indexOf(typeof v === 'undefined' ? 'undefined' : _typeof(v)) > -1) return v;

    return _isEmpty(v);
}

function OneOfTransformer(parsers) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    if (!(this instanceof OneOfTransformer)) {
        return this.transform(new OneOfTransformer(parsers, options));
    }

    this._parsers = parsers;
    this._test = options.test || function (v) {
        return !isEmpty(v);
    };
    this._reverseAll = true;

    if (typeof options.reverseAll === 'boolean') this._reverseAll = options.reverseAll;
}

OneOfTransformer.prototype.parse = function (v) {
    var parsers = this._parsers;
    var len = parsers.length;
    var test = this._test;

    for (var i = 0; i < len; i++) {
        var result = parsers[i].parse(v);

        if (test(result)) return result;
    }

    return;
};

OneOfTransformer.prototype.reverse = function (v) {
    var parsers = this._parsers;
    var len = parsers.length;

    if (len < 1) throw new Error('No parsers defined');

    if (!this._reverseAll) return parsers[0].reverse(v);

    var reversed = {};
    for (var i = 0; i < len; i++) {
        var result = parsers[i].reverse(v);

        if (typeof result === 'undefined') continue;

        if (_isObject(reversed) && _isObject(result)) _merge(reversed, result);else reversed = result;
    }

    return reversed;
};

module.exports = OneOfTransformer;